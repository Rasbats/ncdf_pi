/*********************************************************************
 * Name:      	main.cpp
 * Purpose:   	Implements simple wxWidgets application with GUI
 * 				created using wxFormBuilder.
 * Author:      Mike Rossiter

 * Created:
 * Copyright:
 * License:
 *
 * Notes:		Note that all GUI creation code is implemented in
 * 				gui.cpp source file which is generated by wxFormBuilder.
 *********************************************************************/

#include "stdio.h"
#include "wx/wx.h"
#include "wx/dir.h"
#include <wx/wfstream.h>
#include <wx/sstream.h>
#include <wx/protocol/http.h>
#include <wx/treectrl.h>
#include <wx/treebase.h>
#include <wx/hash.h>
#include <wx/utils.h>
#include <wx/log.h>
#include <wx/stdpaths.h>

#include "folder.xpm"

#include "ncdf.h"
#include "ncdf_reader.h"
#include "ncdfdata.h"
#include "ncdf_pi.h"
#include <vector>

using namespace std;

MainDialog::MainDialog(wxWindow *parent) : ncdfDialog( parent )
{
	this->my_ncdfReader = new ncdfReader(this);
	this->m_parent = parent;
	selectionRectangle.bottomLat = selectionRectangle.bottomLon
	= selectionRectangle.topLat = selectionRectangle.topLon = ncdf_NOTDEF;

	log_window_m = NULL;

	m_bpPrev->SetBitmap(wxBitmap(prev1));
	m_bpNext->SetBitmap(wxBitmap(next1));

	BuildHelpPage();

}

MainDialog::~MainDialog()
{
	if(log_window_m)
		delete log_window_m;
	delete my_ncdfReader;
	pPlugIn->m_choice = m_choiceArea->GetSelection();
}

void MainDialog::setPlugIn(ncdf_pi *p)
{
  this->pPlugIn = p;
  this->m_textCtrlDir->SetValue(pPlugIn->m_ncdf_dir);
  m_choiceArea->SetSelection(pPlugIn->m_choice);
}

void MainDialog::SetCursorLatLon(double lat, double lon)
{
      m_cursor_lon = lon;
      m_cursor_lat = lat;

      UpdateTrackingControls();
}

void MainDialog::UpdateTrackingControls()
{
   this->m_textCtrlCurrentDir->Clear();
   this->m_textCtrlCurrentForce->Clear();
   printCurrentData();
}

void MainDialog::printCurrentData()
{
	  wxString t;
      double cDir;
      double cForce;

      cDir = myMessage.getInterpolatedValue(myMessage, gridu, m_cursor_lon, m_cursor_lat, true);
	  cForce = myMessage.getInterpolatedValue(myMessage, gridv, m_cursor_lon, m_cursor_lat, true);

			if ((cDir != ncdf_NOTDEF) && (cForce != ncdf_NOTDEF))
			{
				double force = sqrt(cDir*cDir + cForce*cForce)*3.6 / 1.852;
				t.Printf(_T("%3.1f"), force);
				this->m_textCtrlCurrentForce->AppendText(t);
				double dir = 90. + (atan2(cForce, -cDir)  * 180. / PI) - 180;
				if (dir < 0) dir = 360 + dir;
				t.Printf(_T("%3.1f"), dir);
				this->m_textCtrlCurrentDir->AppendText(t);
				pPlugIn->ddir = dir;
				pPlugIn->dfor = force;
			}
}

void MainDialog::getCurrentData(double lat, double lon)
{
	wxString t;
	double cDir;
	double cForce;

	cDir = myMessage.getInterpolatedValue(myMessage, gridu, lon, lat, true);
	cForce = myMessage.getInterpolatedValue(myMessage, gridv, lon, lat, true);

	if ((cDir != ncdf_NOTDEF) && (cForce != ncdf_NOTDEF))
	{
		double force = sqrt(cDir*cDir + cForce*cForce)*3.6 / 1.852;
		double dir = 90. + (atan2(cForce, -cDir)  * 180. / PI) - 180;
		if (dir < 0) dir = 360 + dir;
		pPlugIn->ddir = dir;
		pPlugIn->dfor = force;
	}
}


double** MainDialog::makeGridDataCURRENT(ncdfDataMessage message, wxString current){

	int y = message.noPointsMeridian, x = message.noPointsParallel;
	double** grid = new double*[y];
	grid[0] = new double[y*x];
	for (int i = 1; i < y; ++i)
		grid[i] = grid[i - 1] + x;

	unsigned int count = 0;
	int bit = 7;
	unsigned int index;
	index = 0;

	for (unsigned int lat = 0; lat < message.noPointsMeridian; lat++)
	{
		for (unsigned int lon = 0; lon < message.noPointsParallel; lon++)
		{
			if (current == _T("currentu")){
				grid[lat][lon] = message.ucurr[count++];
			}
			else if (current == _T("currentv")){
				grid[lat][lon] = message.vcurr[count++];
			}

		}
	}
	return grid;
}

void MainDialog::onPrev(wxCommandEvent& event) {

	// show some info about this item
	wxTreeItemId itemId = m_treeCtrl->GetFocusedItem();
	MyTreeItemData *item = (MyTreeItemData *)this->m_treeCtrl->GetItemData(itemId);
	this->m_treeCtrl->SetItemDropHighlight(itemId, false);

	if (item != NULL)
	{
		wxTreeItemId tid;
		tid = this->m_treeCtrl->GetPrevSibling(itemId);
		if (tid.IsOk() == true){
			this->m_treeCtrl->SetItemDropHighlight(tid, true);
			this->m_treeCtrl->SetFocusedItem(tid);
			readData(tid);
		}
		else {
			this->m_treeCtrl->SetItemDropHighlight(itemId, true);
			return;
		}
	}
	else {
		return;
	}

}

void MainDialog::onNext(wxCommandEvent& event) {

	// show some info about this item
	wxTreeItemId itemId = m_treeCtrl->GetFocusedItem();
	MyTreeItemData *item = (MyTreeItemData *)this->m_treeCtrl->GetItemData(itemId);
	this->m_treeCtrl->SetItemDropHighlight(itemId, false);

	if (item != NULL)
	{
		wxTreeItemId tid;
		tid = this->m_treeCtrl->GetNextSibling(itemId);
		if (tid.IsOk() == true){
			this->m_treeCtrl->SetItemDropHighlight(tid, true);
			this->m_treeCtrl->SetFocusedItem(tid);
			readData(tid);
		}
		else {
			this->m_treeCtrl->SetItemDropHighlight(itemId, true);
			return;
		}
	}
	else {

		return;
	}

}

void MainDialog::readData(wxTreeItemId itemId) {
	MyTreeItemData *data = (MyTreeItemData *) this->m_treeCtrl->GetItemData(itemId);
	if (data != NULL)
	{
		this->my_ncdfReader->readncdfFile(data->myData);
		pPlugIn->GetncdfOverlayFactory()->renderSelectionRectangle = false;
		RequestRefresh(m_parent);
	}
}



void MainDialog::OnCloseFrame(wxCloseEvent& event) {

}

void MainDialog::onCloseDialog(wxCloseEvent& event)
{
    pPlugIn->OnncdfDialogClose();
}

void MainDialog::OnExitClick(wxCommandEvent& event) {
//	Destroy();
}

void MainDialog::onFileButtonClick(wxCommandEvent& event)
{
	wxDirDialog fd(this,_("Select a directory"),pPlugIn->m_ncdf_dir);

	if(fd.ShowModal() != wxID_OK) return;
	pPlugIn->m_ncdf_dir = fd.GetPath();
	this->m_textCtrlDir->SetValue(pPlugIn->m_ncdf_dir);
	fd.Destroy();
}

int MainDialog::nc_get(wxString filestr){

	int ncid;
	int time_varid, lat_varid, lon_varid;
	int u_varid, v_varid;
	int retval;

	/* We will learn about the data file and store results in these
	program variables. */
	int ndims_in, nvars_in, ngatts_in, unlimdimid_in;

	char* filename = const_cast<char*>((const char*)filestr.mb_str()); // "c:/plugins/Current.grb2";

	/* Open the file. */
	if ((retval = nc_open(filename, NC_NOWRITE, &ncid)))
		ERR(retval);
	/*
	There are a number of inquiry functions in netCDF which can be
	used to learn about an unknown netCDF file. NC_INQ tells how
	many netCDF variables, dimensions, and global attributes are in
	the file; also the dimension id of the unlimited dimension, if
	there is one.
	*/

	if ((retval = nc_inq(ncid, &ndims_in, &nvars_in, &ngatts_in, &unlimdimid_in)))
		ERR(retval);

	if (ndims_in != 3 || unlimdimid_in != -1 || nvars_in != 5) return 2; //||

	int status, latid, lonid, timeid;
	size_t timelength, latlength, lonlength;
	// Obtain the size of the dimensions of time, latitude and longitude
	status = nc_inq_dimid(ncid, "time", &timeid);
	status = nc_inq_dimlen(ncid, timeid, &timelength);
	int time_dim = timelength*sizeof(int);

	status = nc_inq_dimid(ncid, "latitude", &latid);
	status = nc_inq_dimlen(ncid, latid, &latlength);
	int lat_dim = latlength*sizeof(int);

	status = nc_inq_dimid(ncid, "longitude", &lonid);
	status = nc_inq_dimlen(ncid, lonid, &lonlength);
	int lon_dim = lonlength*sizeof(int);
	// End of dimension finding
	//
	// Obtain the identifiers for variables
	if ((retval = nc_inq_varid(ncid, V_NAME, &v_varid))){
		ERR(retval);
	}
	if ((retval = nc_inq_varid(ncid, U_NAME, &u_varid))){
		ERR(retval);
	}
	if ((retval = nc_inq_varid(ncid, TIME_NAME, &time_varid))){
		ERR(retval);
	}
	if ((retval = nc_inq_varid(ncid, LAT_NAME, &lat_varid))){
		ERR(retval);
	}
	if ((retval = nc_inq_varid(ncid, LON_NAME, &lon_varid))){
		ERR(retval);
	}
	// End of identifiers
	//
	float firstGridPointLat;
	float firstGridPointLon;
	float lastGridPointLat;
	float lastGridPointLon;
	float scale_factor;

	// Some additional data from the file
	status = nc_get_att_float(ncid, NC_GLOBAL, "latitude_min", &firstGridPointLat);
	status = nc_get_att_float(ncid, NC_GLOBAL, "longitude_min", &firstGridPointLon);
	status = nc_get_att_float(ncid, NC_GLOBAL, "latitude_max", &lastGridPointLat);
	status = nc_get_att_float(ncid, NC_GLOBAL, "longitude_max", &lastGridPointLon);
	status = nc_get_att_float(ncid, u_varid, "scale_factor", &scale_factor);
	//
	//
	int nbr_uv;

	static size_t start[] = { 0, 0, 0 };
	//
	// count for each area
	static size_t count_ec[] = { 1, NLATEC, NLONEC };
	static size_t count_is[] = { 1, NLATIS, NLONIS };
	static size_t count_sb[] = { 1, NLATSB, NLONSB };
	static size_t count_ns[] = { 1, NLATNS, NLONNS };
	static size_t count_bs[] = { 1, NLATBS, NLONBS };
	static size_t count_wi[] = { 1, NLATWI, NLONWI };
	// End of counts
	//
	float* u_vals = 0;
	float* v_vals = 0;

	int nlatsel;   /// int used to hold NLAT needed for an area
	int nlonsel;

	if (pPlugIn->m_choice == IS){

		nbr_uv = NLATIS * NLONIS;

		u_vals = (float*)calloc(nbr_uv, sizeof(float));
		v_vals = (float*)calloc(nbr_uv, sizeof(float));

		nlatsel = NLATIS;
		nlonsel = NLONIS;

	} else
		if (pPlugIn->m_choice == EC){

			nbr_uv = NLATEC * NLONEC;

			u_vals = (float*)calloc(nbr_uv, sizeof(float));
			v_vals = (float*)calloc(nbr_uv, sizeof(float));

			nlatsel = NLATEC;
			nlonsel = NLONEC;
		}else
			if (pPlugIn->m_choice == SB){

				nbr_uv = NLATSB * NLONSB;

				u_vals = (float*)calloc(nbr_uv, sizeof(float));
				v_vals = (float*)calloc(nbr_uv, sizeof(float));

				nlatsel = NLATSB;
				nlonsel = NLONSB;
			}else
				if (pPlugIn->m_choice == NS){

					nbr_uv = NLATNS * NLONNS;

					u_vals = (float*)calloc(nbr_uv, sizeof(float));
					v_vals = (float*)calloc(nbr_uv, sizeof(float));

					nlatsel = NLATNS;
					nlonsel = NLONNS;
				}
				else
					if (pPlugIn->m_choice == BS){

						nbr_uv = NLATBS * NLONBS;

						u_vals = (float*)calloc(nbr_uv, sizeof(float));
						v_vals = (float*)calloc(nbr_uv, sizeof(float));

						nlatsel = NLATBS;
						nlonsel = NLONBS;
					}
					else
						if (pPlugIn->m_choice == WI){

							nbr_uv = NLATWI * NLONWI;

							u_vals = (float*)calloc(nbr_uv, sizeof(float));
							v_vals = (float*)calloc(nbr_uv, sizeof(float));

							nlatsel = NLATWI;
							nlonsel = NLONWI;
						}


	int count_records = 0;
	int startminutes = 0;
	int *time_out;

	time_out = (int*)calloc(192 + 1, sizeof(int));

	nc_get_var_int(ncid, time_varid, time_out);

	float* lats = 0, *lons = 0;

	lats = (float*)calloc(lat_dim + 1, sizeof(float));
	lons = (float*)calloc(lon_dim + 1, sizeof(float));

	nc_get_var_float(ncid, lat_varid, lats);
	nc_get_var_float(ncid, lon_varid, lons);

	int i, j, k;
	for (i = 0; i < timelength; i++) {

		start[0] = i;
		count_records = 0;

		if (pPlugIn->m_choice == EC){
			status = nc_get_vara_float(ncid, u_varid, start, count_ec, (float*)u_vals);
			status = nc_get_vara_float(ncid, v_varid, start, count_ec, (float*)v_vals);
		}
		else
			if (pPlugIn->m_choice == IS){
				status = nc_get_vara_float(ncid, u_varid, start, count_is, (float*)u_vals);
				status = nc_get_vara_float(ncid, v_varid, start, count_is, (float*)v_vals);
			}
			else
				if (pPlugIn->m_choice == SB){
					status = nc_get_vara_float(ncid, u_varid, start, count_sb, (float*)u_vals);
					status = nc_get_vara_float(ncid, v_varid, start, count_sb, (float*)v_vals);
				}
				else
					if (pPlugIn->m_choice == NS){
						status = nc_get_vara_float(ncid, u_varid, start, count_ns, (float*)u_vals);
						status = nc_get_vara_float(ncid, v_varid, start, count_ns, (float*)v_vals);
					}
					else
						if (pPlugIn->m_choice == BS){
							status = nc_get_vara_float(ncid, u_varid, start, count_bs, (float*)u_vals);
							status = nc_get_vara_float(ncid, v_varid, start, count_bs, (float*)v_vals);
						}
						else
							if (pPlugIn->m_choice == WI){
								status = nc_get_vara_float(ncid, u_varid, start, count_wi, (float*)u_vals);
								status = nc_get_vara_float(ncid, v_varid, start, count_wi, (float*)v_vals);
							}

		myncdfData.ucurr = (double*)calloc(nbr_uv + 1, sizeof(double));
		myncdfData.vcurr = (double*)calloc(nbr_uv + 1, sizeof(double));
		myncdfData.uvlats = (double*)calloc(nbr_uv + 1, sizeof(double));
		myncdfData.uvlons = (double*)calloc(nbr_uv + 1, sizeof(double));

		for (j = 0; j < nlatsel; j++){
			for (k = 0; k < nlonsel; k++){
				if (u_vals[count_records] != -32767 && v_vals[count_records] != -32767){
					myncdfData.uvlats[count_records] = (double)lats[j];
					myncdfData.uvlons[count_records] = (double)lons[k];
					myncdfData.ucurr[count_records] = (double)u_vals[count_records] / 1000;
					myncdfData.vcurr[count_records] = (double)v_vals[count_records] / 1000;
				}
				else{
					myncdfData.uvlats[count_records] = NULL;
					myncdfData.uvlons[count_records] = NULL;
					myncdfData.ucurr[count_records] = NULL;
					myncdfData.vcurr[count_records] = NULL;
				}
				count_records++;
			}
		}

        wxDateTime dt;
		dt = GetDateFromHours(time_out[i]);

		myncdfData.dataDateTime = dt;
		myncdfData.minutesAfterStart = startminutes;
		myncdfData.numberOfPoints = count_records - 1;
		myncdfData.noPointsParallel = nlonsel;
		myncdfData.noPointsMeridian = nlatsel;
		myncdfData.firstGridPointLat = firstGridPointLat;
		myncdfData.firstGridPointLong = firstGridPointLon;
		myncdfData.lastGridPointLat = lastGridPointLat;
		myncdfData.lastGridPointLong = lastGridPointLon;
		myncdfData.iDirectionIncr = 0.02777863;
		myncdfData.jDirectionIncr = 0.02777863;
		myncdfData.fileName = filename;

		myDataVector.push_back(myncdfData);

		startminutes = startminutes + 60;
	}

	/* Close the file. */
	if ((retval = nc_close(ncid)))
		ERR(retval);

	free(u_vals);
	free(v_vals);
	free(lats);
	free(lons);
	free(time_out);

	return 0;
}

wxDateTime MainDialog::GetDateFromHours(int hours_in){

	wxString baseDateTime = _T("2011-12-31 00:00:00");

	wxDateTime m_dt;
	m_dt.ParseDateTime(baseDateTime);

	wxTimeSpan m_ts = wxTimeSpan::Hours(hours_in);
	m_dt.Add(m_ts);

	return m_dt;
}


void MainDialog::onDirChanged(wxCommandEvent& event)
{
	wxStandardPathsBase &std_path = wxStandardPathsBase::Get();
	wxString std = std_path.GetDocumentsDir();

	if(this->m_textCtrlDir->GetValue().length() != 0 && pPlugIn->m_ncdf_dir != std_path.GetDocumentsDir())
		fillDirTree(this->m_textCtrlDir->GetValue(), true, 0);
	else
		this->m_treeCtrl->DeleteAllItems();
}

void MainDialog::onTreeSelectionChanged(wxTreeEvent& event)
{
	if(this->my_ncdfReader->isReading == true){ncdfDialog::onTreeSelectionChanged(event); return; }

 	if(this->m_treeCtrl->GetRootItem() == event.GetItem())
		return;

	wxString filename = this->m_treeCtrl->GetItemText(event.GetItem());
	MyTreeItemData *data = (MyTreeItemData *) this->m_treeCtrl->GetItemData(event.GetItem());
	if(data != NULL)
	{
		this->my_ncdfReader->readncdfFile(data->myData);
		pPlugIn->GetncdfOverlayFactory()->renderSelectionRectangle = false;
		RequestRefresh(m_parent);
	}

	ncdfDialog::onTreeSelectionChanged(event);
}

void MainDialog::onAreaChange(wxCommandEvent& event){

	pPlugIn->m_choice = m_choiceArea->GetSelection();
	fillDirTree(this->m_textCtrlDir->GetValue(), true, 0);  // Refill tree to show different area
	pPlugIn->b_showODAS = false; // If using tidal arrows cancel them
	m_ArrowList.clear();
}

void MainDialog::onTreeItemRightClick(wxTreeEvent& event)
{
    if(this->m_treeCtrl->GetRootItem() == event.GetItem())
		return;

    wxTreeItemId id =  this->m_treeCtrl->GetSelection();
    MyTreeItemData *data = (MyTreeItemData *) this->m_treeCtrl->GetItemData(id);
}

void MainDialog::onDCurrentClick( wxCommandEvent& event )
{
	RequestRefresh(m_parent);
}
void MainDialog::onBmpCurrentForceClick(wxCommandEvent& event)
{
	RequestRefresh(m_parent);
}

void MainDialog::fillDirTree(wxString path, bool start, wxTreeItemId id)
{
    wxString file ;

	if(start == true)
	{
		this->m_treeCtrl->DeleteAllItems();
		id = this->m_treeCtrl->AddRoot(_T(""));
		this->m_treeCtrl->SetItemText(id,_("ncdf-Files"));
		this->m_treeCtrl->SelectItem(id);
	}

	wxDir dir(path);
	if(dir.IsOpened() && dir.HasFiles())
	{
		wxString s;
		dir.GetFirst(&s);
		file = path +_("/") + s;

		ncdfDataMessage dm;
		wxTreeItemId iid = this->m_treeCtrl->AppendItem(id,s);
		this->m_treeCtrl->SetItemData(iid, new MyTreeItemData(NULL, 0, &dm, &file));


		addChildren(iid,s);

		while(dir.GetNext(&s))
		{
			file = path +_("/") + s;
			wxTreeItemId iid = this->m_treeCtrl->AppendItem(id,s);
			this->m_treeCtrl->SetItemData(iid, new MyTreeItemData(NULL, 0, &dm, &file));
			addChildren(iid, s);
		}
		this->m_treeCtrl->Expand(id);
	}
}

void MainDialog::addChildren(wxTreeItemId id, wxString fn)
{
	char s[2] = {'m','h'};
	wxFileOffset fp = 0;
	wxDateTime dt;
	wxUint32 hours = 0;
	wxString fileName;

	fileName = this->m_textCtrlDir->GetValue()+_("/")+fn;
	myDataVector.clear();
	nc_get(fileName);  //The important bit for making a data message

	for (vector<ncdfDataMessage>::iterator it = myDataVector.begin(); it != myDataVector.end(); it++){

		int fromStart;
		fromStart = (*it).minutesAfterStart;
		dt = (*it).dataDateTime;
		myData = (*it);

		wxTreeItemId itemId = this->m_treeCtrl->AppendItem(id, _T(""));
		this->m_treeCtrl->SetItemText(itemId, wxString::Format(_("%03i %s Forecast"), fromStart, "m"));
		this->m_treeCtrl->SetItemData(itemId, new MyTreeItemData(&dt, fromStart, &myData, &fileName));
	}

}

void MainDialog::OnContextMenu(double m_lat, double m_lon){

	// show some info about this item
	wxTreeItemId itemId = m_treeCtrl->GetFocusedItem();
	MyTreeItemData *item = (MyTreeItemData *)this->m_treeCtrl->GetItemData(itemId);

	if (item == NULL)
	{
		return;
	}

	int response;
	wxMessageDialog *dial = new wxMessageDialog(NULL, _T("Show tidal current at the cursor position?"), wxT("Proceed?"), wxOK | wxCANCEL);

	response = dial->ShowModal();

	if (response == wxID_OK) {
		pPlugIn->b_showODAS = true;
		Arrow *m_Arrow = new Arrow;
		m_Arrow->m_lat = m_lat;
		m_Arrow->m_lon = m_lon;
		m_ArrowList.push_back(m_Arrow);
	}
	else{
		pPlugIn->b_showODAS = false;
		m_ArrowList.clear();

		return;
	}
}

void MainDialog::BuildHelpPage(){

	wxString myHelp;
	myHelp = _("This page is intended to help users download \nthe areas to use with the ncdf plugin.\n\nThe display Areas for ncdf Tidal Currents\n are as follows:\n\nFormat: \nLat(Min), Lat(Max), Lon(Min), Lon(Max)\n\nEnglish Channel:           48, 51, -7, -2\nIrish Sea:                         50, 56, -9, -2\nSouthern Brittany:         46.5, 48.5, -5.5, -0.5\nNorth Sea:                      51, 56, -2.5, 5\nBiscay South:                 43, 47, -9.5, -0.5\nWestern Ireland:            50, 56, -12, -8               ");
	m_staticText6->SetLabel(myHelp);
}


MyTreeItemData::MyTreeItemData(wxDateTime *dt, wxUint32 hour, ncdfDataMessage *myData, wxString *myFile)
{
	this->hour = hour; this->myData = *myData; this->myFile;
	if(dt)
	{
		this->dt = wxDateTime(*dt);
		wxString d = this->dt.FormatDate();
	}
}

