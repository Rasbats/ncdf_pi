/*********************************************************************
 * Name:      	main.cpp
 * Purpose:   	Implements simple wxWidgets application with GUI
 * 				created using wxFormBuilder.
 * Author:

 * Created:
 * Copyright:
 * License:   	wxWidgets license (www.wxwidgets.org)
 *
 * Notes:		Note that all GUI creation code is implemented in
 * 				gui.cpp source file which is generated by wxFormBuilder.
 *********************************************************************/

#include "stdio.h"
#include "wx/wx.h"
#include "wx/dir.h"
#include <wx/wfstream.h>
#include <wx/sstream.h>
#include <wx/protocol/http.h>
#include <wx/treectrl.h>
#include <wx/hash.h>
#include <wx/utils.h>
#include <wx/log.h>
#include <wx/stdpaths.h>

//#include "folder.xpm"

#include "ncdf.h"
#include "ncdf_reader.h"
#include "ncdfdata.h"
#include "ncdf_pi.h"

MainDialog::MainDialog(wxWindow *parent) : ncdfDialog( parent ) 
{
	this->my_ncdfReader = new ncdfReader(this);
	this->m_parent = parent;
	selectionRectangle.bottomLat = selectionRectangle.bottomLon 
	= selectionRectangle.topLat = selectionRectangle.topLon = ncdf_NOTDEF;

	log_window_m = NULL;
}

MainDialog::~MainDialog() 
{
	if(log_window_m)
		delete log_window_m;
	delete my_ncdfReader;
}

void MainDialog::setPlugIn(ncdf_pi *p)
{
  this->pPlugIn = p;
  this->m_textCtrlDir->SetValue(pPlugIn->m_ncdf_dir);
}

void MainDialog::SetCursorLatLon(double lat, double lon)
{
      m_cursor_lon = lon;
      m_cursor_lat = lat;

      UpdateTrackingControls();
}

void MainDialog::UpdateTrackingControls()
{
   this->m_textCtrlCurrentDir->Clear();
   this->m_textCtrlCurrentForce->Clear();  
   printCurrentData();
}

void MainDialog::printCurrentData()
{	
	  wxString t;
      double cDir;
      double cForce;

      cDir = myMessage.getInterpolatedValue(myMessage, gridu, m_cursor_lon, m_cursor_lat, true);
	  cForce = myMessage.getInterpolatedValue(myMessage, gridv, m_cursor_lon, m_cursor_lat, true);

			if ((cDir != ncdf_NOTDEF) && (cForce != ncdf_NOTDEF))
			{
				double force = sqrt(cDir*cDir + cForce*cForce)*3.6 / 1.852;
				t.Printf(_T("%3.1f"), force);
				this->m_textCtrlCurrentForce->AppendText(t);
				double dir = 90. + (atan2(cForce, -cDir)  * 180. / PI) - 180;
				if (dir < 0) dir = 360 + dir;
				t.Printf(_T("%3.1f"), dir);
				this->m_textCtrlCurrentDir->AppendText(t);
			}
}


double** MainDialog::makeGridDataCURRENT(ncdfDataMessage message, wxString current){

	int y = message.noPointsMeridian, x = message.noPointsParallel;
	double** grid = new double*[y];
	grid[0] = new double[y*x];
	for (int i = 1; i < y; ++i)
		grid[i] = grid[i - 1] + x;

	unsigned int count = 0;
	int bit = 7;
	unsigned int index;
	index = 0;

	for (unsigned int lat = 0; lat < message.noPointsMeridian; lat++)
	{
		for (unsigned int lon = 0; lon < message.noPointsParallel; lon++)
		{			
			if (current == _T("currentu")){
				grid[lat][lon] = message.ucurr[count++];
			}
			else if (current == _T("currentv")){
				grid[lat][lon] = message.vcurr[count++];
			}
			
		}
	}
	return grid;
}

void MainDialog::OnCloseFrame(wxCloseEvent& event) {

}

void MainDialog::onCloseDialog(wxCloseEvent& event)
{ 
    pPlugIn->OnncdfDialogClose();   
}

void MainDialog::OnExitClick(wxCommandEvent& event) {
//	Destroy();
}

void MainDialog::onFileButtonClick(wxCommandEvent& event) 
{
	wxDirDialog fd(this,_("Select a directory"),pPlugIn->m_ncdf_dir);

	if(fd.ShowModal() != wxID_OK) return;
	pPlugIn->m_ncdf_dir = fd.GetPath();
	this->m_textCtrlDir->SetValue(pPlugIn->m_ncdf_dir);
	fd.Destroy();
}

int MainDialog::nc_get(wxString filestr){

	int ncid;
	int time_varid, lat_varid, lon_varid;
	int u_varid, v_varid;
	int retval;

	/* We will learn about the data file and store results in these
	program variables. */
	int ndims_in, nvars_in, ngatts_in, unlimdimid_in;

	char* filename = const_cast<char*>((const char*)filestr.mb_str()); // "c:/plugins/Current.grb2";

	/* Open the file. */
	if ((retval = nc_open(filename, NC_NOWRITE, &ncid)))
		ERR(retval);
	/* 
	There are a number of inquiry functions in netCDF which can be
	used to learn about an unknown netCDF file. NC_INQ tells how
	many netCDF variables, dimensions, and global attributes are in
	the file; also the dimension id of the unlimited dimension, if
	there is one. 
	*/

	if ((retval = nc_inq(ncid, &ndims_in, &nvars_in, &ngatts_in, &unlimdimid_in)))
		ERR(retval);

	if (ndims_in != 3 || unlimdimid_in != -1 || nvars_in != 5) return 2; //|| 

	int status, latid, lonid, timeid;
	size_t timelength, latlength, lonlength;

	status = nc_inq_dimid(ncid, "time", &timeid);
	status = nc_inq_dimlen(ncid, timeid, &timelength);
	int time_dim = timelength*sizeof(int);

	status = nc_inq_dimid(ncid, "latitude", &latid);
	status = nc_inq_dimlen(ncid, latid, &latlength);
	int lat_dim = latlength*sizeof(int);

	status = nc_inq_dimid(ncid, "longitude", &lonid);
	status = nc_inq_dimlen(ncid, lonid, &lonlength);

	int lon_dim = lonlength*sizeof(int);

	if (lat_dim/4 < NLAT ){
		wxString mb = _T("The latitude range for the NetCDF file ");
		mb = mb + filestr;
		wxString mbl = mb + _T(" is too small");

		wxMessageBox(mbl, _T("NetCDF file size error"));
		return 2;
	}
	else if (lon_dim / 4 < NLON){
		wxString mb = _T("The longitude range for the NetCDF file ");
		mb = mb + filestr;
		wxString mbl = mb + _T(" is too small");

		wxMessageBox(mbl, _T("NetCDF file size error"));
		return 2;

	}

	if ((retval = nc_inq_varid(ncid, V_NAME, &v_varid))){
		ERR(retval);
	}
	if ((retval = nc_inq_varid(ncid, U_NAME, &u_varid))){
		ERR(retval);
	}
	if ((retval = nc_inq_varid(ncid, TIME_NAME, &time_varid))){
		ERR(retval);
	}
	if ((retval = nc_inq_varid(ncid, LAT_NAME, &lat_varid))){
		ERR(retval);
	}
	if ((retval = nc_inq_varid(ncid, LON_NAME, &lon_varid))){
		ERR(retval);
	}

	float firstGridPointLat;
	float firstGridPointLon;
	float lastGridPointLat;
	float lastGridPointLon;

	float scale_factor;

	status = nc_get_att_float(ncid, NC_GLOBAL, "latitude_min", &firstGridPointLat);
	status = nc_get_att_float(ncid, NC_GLOBAL, "longitude_min", &firstGridPointLon);
	status = nc_get_att_float(ncid, NC_GLOBAL, "latitude_max", &lastGridPointLat);
	status = nc_get_att_float(ncid, NC_GLOBAL, "longitude_max", &lastGridPointLon);

	status = nc_get_att_float(ncid, u_varid, "scale_factor", &scale_factor);
	
	int nbr_uv;
	
	nbr_uv = NLAT*NLON;
	
	static size_t start[] = { 0, 0, 0 };
	static size_t count[] = { 1, NLAT, NLON };

	float u_vals[1][NLAT][NLON];
	float v_vals[1][NLAT][NLON];

	int count_records = 0;

	//if ((retval = nc_inq_varid(ncid, TIME_NAME, &time_varid))){
		//ERR(retval);
	//}

	int startminutes = 0;
	int time_out[48];
	nc_get_var_int(ncid, time_varid, (int*)time_out);
	
	float* lats = 0, *lons = 0;
	
	lats = (float*)calloc(lat_dim + 1, sizeof(float));
	lons = (float*)calloc(lon_dim + 1, sizeof(float));

	nc_get_var_float(ncid, lat_varid, lats);
	nc_get_var_float(ncid, lon_varid, lons);

	int i, j, k;
	for (i = 0; i < timelength; i++) {

		start[0] = i;
		count_records = 0;

	    status = nc_get_vara_float(ncid, u_varid, start, count, (float*)u_vals);
		status = nc_get_vara_float(ncid, v_varid, start, count, (float*)v_vals);

		myncdfData.ucurr = (double*)calloc(nbr_uv + 1, sizeof(double));
		myncdfData.vcurr = (double*)calloc(nbr_uv + 1, sizeof(double));
		myncdfData.uvlats = (double*)calloc(nbr_uv + 1, sizeof(double));
		myncdfData.uvlons = (double*)calloc(nbr_uv + 1, sizeof(double));

		for (j = 0; j < NLAT; j++){
			for (k = 0; k < NLON; k++){
				if (u_vals[0][j][k] != -32767 && v_vals[0][j][k] != -32767){					
					myncdfData.uvlats[count_records] = (double)lats[j];
					myncdfData.uvlons[count_records] = (double)lons[k];
					myncdfData.ucurr[count_records] = (double)u_vals[0][j][k] / 1000;
					myncdfData.vcurr[count_records] = (double)v_vals[0][j][k] / 1000;				
				}
				else{
					myncdfData.uvlats[count_records] = NULL;
					myncdfData.uvlons[count_records] = NULL;
					myncdfData.ucurr[count_records] = NULL;
					myncdfData.vcurr[count_records] = NULL;
				}
				count_records++;
			}
		}

        wxDateTime dt;
		dt = GetDateFromHours(time_out[i]);

		//wxString d = wxString::Format(_T("%i"), time_out[i]);
		//wxString d = dt.Format(_T("%d %b %Y %H:%M"));
		//wxMessageBox(d);
		myncdfData.dataDateTime = dt;
		myncdfData.minutesAfterStart = startminutes;
		myncdfData.numberOfPoints = count_records - 1;
		myncdfData.noPointsParallel = NLON;
		myncdfData.noPointsMeridian = NLAT;
		myncdfData.firstGridPointLat = firstGridPointLat;
		myncdfData.firstGridPointLong = firstGridPointLon;
		myncdfData.lastGridPointLat = lastGridPointLat;
		myncdfData.lastGridPointLong = lastGridPointLon;
		myncdfData.iDirectionIncr = 0.02777863;
		myncdfData.jDirectionIncr = 0.02777863;
		myncdfData.fileName = filename;

		myDataVector.push_back(myncdfData);

		startminutes = startminutes + 60;		
	}

	/* Close the file. */
	if ((retval = nc_close(ncid)))
		ERR(retval);

	return 0;
}

wxDateTime MainDialog::GetDateFromHours(int hours_in){

	wxString baseDateTime = _T("2011-03-31 00:00:00");
	
	wxDateTime m_dt;
	m_dt.ParseDateTime(baseDateTime);

	wxTimeSpan m_ts = wxTimeSpan::Hours(hours_in + 1);
	m_dt.Add(m_ts);

	//wxString d  = m_dt.Format(_T("%d %b %Y %H:%M"));
	//wxMessageBox(d);
	return m_dt;
}


void MainDialog::onDirChanged(wxCommandEvent& event) 
{
	wxStandardPathsBase &std_path = wxStandardPathsBase::Get(); 
	wxString std = std_path.GetDocumentsDir();

	if(this->m_textCtrlDir->GetValue().length() != 0 && pPlugIn->m_ncdf_dir != std_path.GetDocumentsDir()) 
		fillDirTree(this->m_textCtrlDir->GetValue(), true, 0);
	else
		this->m_treeCtrl->DeleteAllItems();
}

void MainDialog::onTreeSelectionChanged(wxTreeEvent& event) 
{
	if(this->my_ncdfReader->isReading == true){ 	ncdfDialog::onTreeSelectionChanged(event); return; }
 	if(this->m_treeCtrl->GetRootItem() == event.GetItem()) 
		return;
	wxString filename = this->m_treeCtrl->GetItemText(event.GetItem());	
	MyTreeItemData *data = (MyTreeItemData *) this->m_treeCtrl->GetItemData(event.GetItem());
	if(data != NULL)  
	{
		this->my_ncdfReader->readncdfFile(data->myData);	
		pPlugIn->GetncdfOverlayFactory()->renderSelectionRectangle = false;		
		RequestRefresh(m_parent);
	}

	ncdfDialog::onTreeSelectionChanged(event);
}

void MainDialog::onTreeItemRightClick(wxTreeEvent& event)
{
    if(this->m_treeCtrl->GetRootItem() == event.GetItem()) 
		return; 
    
    wxTreeItemId id =  this->m_treeCtrl->GetSelection();
    MyTreeItemData *data = (MyTreeItemData *) this->m_treeCtrl->GetItemData(id);   
}

void MainDialog::onDCurrentClick( wxCommandEvent& event )
{
	RequestRefresh(m_parent);  
}
void MainDialog::onBmpCurrentForceClick(wxCommandEvent& event)
{
	RequestRefresh(m_parent);
}

void MainDialog::fillDirTree(wxString path, bool start, wxTreeItemId id) 
{
    wxString file ;
    
	if(start == true) 
	{
		this->m_treeCtrl->DeleteAllItems();
		id = this->m_treeCtrl->AddRoot(_T(""));
		this->m_treeCtrl->SetItemText(id,_("ncdf-Files"));
		this->m_treeCtrl->SelectItem(id);
	}

	wxDir dir(path);
	if(dir.IsOpened() && dir.HasFiles())
	{
		wxString s;
		dir.GetFirst(&s);
		file = path +_("/") + s;
		
		ncdfDataMessage dm;
		wxTreeItemId iid = this->m_treeCtrl->AppendItem(id,s);
		this->m_treeCtrl->SetItemData(iid, new MyTreeItemData(NULL, 0, &dm, &file));


		addChildren(iid,s);
		
		while(dir.GetNext(&s)) 
		{
			file = path +_("/") + s;
			wxTreeItemId iid = this->m_treeCtrl->AppendItem(id,s);
			this->m_treeCtrl->SetItemData(iid, new MyTreeItemData(NULL, 0, &dm, &file));			
			addChildren(iid, s);			
		}
		this->m_treeCtrl->Expand(id);		
	}
}

void MainDialog::addChildren(wxTreeItemId id, wxString fn)
{
	char s[2] = {'m','h'};
	wxFileOffset fp = 0;
	wxDateTime dt;
	wxUint32 hours = 0;
	wxString fileName;

	fileName = this->m_textCtrlDir->GetValue()+_("/")+fn;	
	myDataVector.clear();
	nc_get(fileName);  //The important bit for making a data message
	
	for (vector<ncdfDataMessage>::iterator it = myDataVector.begin(); it != myDataVector.end(); it++){

		int fromStart;
		fromStart = (*it).minutesAfterStart;
		dt = (*it).dataDateTime;
		myData = (*it);

		wxTreeItemId itemId = this->m_treeCtrl->AppendItem(id, _T(""));
		this->m_treeCtrl->SetItemText(itemId, wxString::Format(_("%03i %s Forecast"), fromStart, "m"));
		this->m_treeCtrl->SetItemData(itemId, new MyTreeItemData(&dt, fromStart, &myData, &fileName));
	}

}

MyTreeItemData::MyTreeItemData(wxDateTime *dt, wxUint32 hour, ncdfDataMessage *myData, wxString *myFile)
{ 	
	this->hour = hour; this->myData = *myData; this->myFile;
	if(dt)
	{
		this->dt = wxDateTime(*dt);
		wxString d = this->dt.FormatDate();
	}
}
